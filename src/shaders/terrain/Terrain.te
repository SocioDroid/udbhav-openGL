#version 460 core

layout(quads, fractional_odd_spacing, ccw) in;

uniform sampler2D heightMap;
uniform mat4 u_modelMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_projectionMatrix;

uniform vec3 lightPosition;
uniform vec3 viewPosition;

uniform vec4 u_plane;

in vec2 a_texcoord_tcs_out[];
in vec3 FragPos_tcs_out[];
in vec3 TangentLightPos_tcs_out[];
in vec3 TangentViewPos_tcs_out[];
in vec3 TangentFragPos_tcs_out[];

out float Height;
out vec2 a_texcoord_tes_out;
out vec3 FragPos_tes_out;
out vec3 TangentLightPos_tes_out;
out vec3 TangentViewPos_tes_out;
out vec3 TangentFragPos_tes_out;
out vec3 DOF_View_transformed;
out vec3 a_position_out;

out vec3 f_Col;
out float distFromPos;
out float dispFactor;
out float height;
out mat3 TBN_out;

out float gl_ClipDistance[1];

void main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec2 t00 = a_texcoord_tcs_out[0];
    vec2 t01 = a_texcoord_tcs_out[1];
    vec2 t10 = a_texcoord_tcs_out[2];
    vec2 t11 = a_texcoord_tcs_out[3];

    vec2 t0 = mix(t00, t01, gl_TessCoord.x);
    vec2 t1 = mix(t10, t11, gl_TessCoord.x);
    vec2 texCoord = mix(t0, t1, gl_TessCoord.y);
    a_texcoord_tes_out = texCoord;

    Height = texture(heightMap, texCoord).y * 300.0 - 16.0;

    vec4 p00 = gl_in[0].gl_Position;
    vec4 p01 = gl_in[1].gl_Position;
    vec4 p10 = gl_in[2].gl_Position;
    vec4 p11 = gl_in[3].gl_Position;

    vec4 uVec = p01 - p00;
    vec4 vVec = p10 - p00;
    vec4 normal = normalize( vec4(cross(vVec.xyz, uVec.xyz), 0) );

    vec4 p0 = (p01 - p00) * u + p00;
    vec4 p1 = (p11 - p10) * u + p10;
    vec4 p = (p1 - p0) * v + p0 + normal * Height;

    height = p[1];

    FragPos_tes_out = vec3(u_modelMatrix * p); // worldPosition

    //mat3 normalMatrix = transpose(inverse(mat3(u_modelMatrix)));
    //vec3 T = normalize(normalMatrix * vec3(0.0,1.0,0.0));
    //vec3 N = normalize(normalMatrix * vec3(normal));
    //T = normalize(T - dot(T, N) * N);
    //vec3 B = cross(N, T);
    //mat3 TBN = transpose(mat3(T, B, N)); 

    //TangentLightPos_tes_out = TBN * lightPosition;
    //TangentViewPos_tes_out  = TBN * viewPosition;
    //TangentFragPos_tes_out  = TBN * FragPos_tes_out;

    float totalMapSize = 400.0;
    float totalPixels = 2048.0;
    float cellSize = totalMapSize/totalPixels;

    // Need To Calculate a_tangent & a_normal
    float heightL = texture(heightMap,texCoord - vec2(1.0/totalPixels,0)).r*10.0;
    float heightR = texture(heightMap,texCoord + vec2(1.0/totalPixels,0)).r*10.0;
    float heightD = texture(heightMap,texCoord - vec2(0,1.0/totalPixels)).r*10.0;
    float heightU = texture(heightMap,texCoord + vec2(0,1.0/totalPixels)).r*10.0;
	vec3 tangent = normalize(vec3(cellSize,heightL - heightR,0));
    vec3 bitangent = normalize(vec3(0,heightD - heightU,cellSize));
   
    mat3 normalMatrix = transpose(inverse(mat3(u_modelMatrix)));
	vec3 T = normalize(normalMatrix * tangent);
	vec3 N = normalize(normalMatrix * vec3(normal));
	T = normalize(T - dot(T, N) * N);
	vec3 B = cross(N, T);

	mat3 TBN = transpose(mat3(T, B, N));
	TangentLightPos_tes_out = TBN * lightPosition;
	TangentViewPos_tes_out = TBN * viewPosition;
	TangentFragPos_tes_out = TBN * FragPos_tes_out;
    TBN_out = TBN;

    vec4 DOF_P = u_viewMatrix * u_modelMatrix * p;
    DOF_View_transformed = -DOF_P.xyz;
    a_position_out = vec3(p);
    gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * p;
    gl_ClipDistance[0] = dot(u_modelMatrix * p, u_plane);

}
